---
layout: post
title:  "Go 入门指南 - 基本结构和基本数据类型 - 2"
date:   2019-03-01 13:00:00

categories: go
tags: learningnote
author: "Victor"
---

## 常量

* 常量使用关键字 const 定义，用于存储不会改变的数据。
* 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
* 常量的定义格式：`const identifier [type] = value`
* 你可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型。

```go
const Pi = 3.14159
```

* 显式类型定义： `const b string = "abc"`
* 隐式类型定义： `const b = "abc"`

一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。

```go
var n int
f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int
```

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

* 正确的做法：`const c1 = 2/3`
* 错误的做法：`const c2 = getNumber() // 引发构建错误: getNumber() used as value`

**因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。**

* 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出
* 反斜杠 `\` 可以在常量表达式中作为多行的连接符使用。
* 当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。

常量也允许使用并行赋值的形式：

```go
const beef, two, c = "meat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
    Monday, Tuesday, Wednesday = 1, 2, 3
    Thursday, Friday, Saturday = 4, 5, 6
)
```

常量还可以用作枚举：

```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```

### iota

略

## 变量

* 声明变量的一般形式是使用 `var` 关键字：`var identifier type`
* 一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil
* 变量的命名规则遵循骆驼命名法
* 如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用
* 函数体内声明的变量称之为局部变量，它们的作用域只在函数体内
* 变量可以编译期间就被赋值，也可以在运行时对变量进行赋值操作
* 一般情况下，只有类型相同的变量之间才可以相互赋值
* 声明与赋值（初始化）语句也可以组合起来 `var a int = 15`
* Go 编译器可以根据变量的值来自动推断其类型 `var i = 5`
* 自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型 `var n int64 = 2`
* 变量的类型也可以在运行时实现自动推断，例如：`HOME = os.Getenv("HOME")`
* 在函数体内声明局部变量时，应使用简短声明语法 `:=` 例如 `a := 1`，这叫做 **初始化声明**
* 交换两个变量的值 `a, b = b, a`
* `_` 是一个只写变量，也用于抛弃值，**这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。**

```go

```

```go
var (
    a int
    b bool
    str string
)
```

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    var goos string = os.Getenv("GOOS")
    fmt.Printf("The operating system is: %s\n", goos)
    path := os.Getenv("PATH")
    fmt.Printf("Path is %s\n", path)
}
```

下面展示一个小技巧

```go
// 同一类型的多个变量可以声明在同一行
var a, b, c int
// 多变量可以在同一行进行赋值
a, b, c = 5, 7, "abc"
```

```go
// 更简短的写法
a, b, c := 5, 7, "abc"
```

```go
// 你并不需要使用从一个函数得到的所有返回值
_, b = 5, 7
```

```go
// 并行赋值也被用于当一个函数返回多个返回值时
val, err = Func1(var1)
```

### 错误的语法

* `var a` 这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据
* 不可以声明了一个局部变量却没有在相同的代码块中使用它
* 不可以多次初始化一个变量
* 不可以不声明变量就使用它

### 值类型和引用类型

* int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值
* 数组 和 结构 这些复合类型也是值类型
* 使用等号 `=` 将一个变量的值赋值给另一个变量时，`j = i` 实际上是在内存中将 i 的值进行了拷贝
* 通过 `&i` 来获取变量 i 的内存地址，值类型的变量的值存储在栈中
* 复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存
* 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置，**这个内存地址为称之为指针**，这个指针实际上也被存在另外的某一个字中

### init 函数

* 不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。
* 每一个源文件都可以包含且只包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。
* 可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。
* 经常被用在当一个程序开始之前调用后台执行的 goroutine

```go
package trans

import "math"

var Pi float64

func init() {
   Pi = 4 * math.Atan(1) // init() function computes Pi
}
```

```go
package main

import (
   "fmt"
   "./trans"
)

var twoPi = 2 * trans.Pi

func main() {
   fmt.Printf("2*Pi = %g\n", twoPi) // 2*Pi = 6.283185307179586
}
```
