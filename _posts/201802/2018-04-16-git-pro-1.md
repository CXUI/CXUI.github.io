---
layout: post
title:  "Pro Git 笔记"
date:   2018-04-16 12:00:00

categories: tool
tags: git
author: "Victor"
---

## 起步

Git 在高度易用的同时，仍然保留着初期设定的目标。若是理解了 Git 的思想和基本工作原理，用起来就会知其然知其所以然，游刃有余。

Git 只关心文件数据的整理是否发生变化，而大多数其他系统则关心文件内容的具体差异。

对于任何一个文件，在 Git 内部都只有三种状态：

* 已提交 Committed - 安全的保存在本地数据库中
* 已修改 modified - 修改了某个文件，但还没有提交保存
* 已暂存 staged - 已修改的文件放在下次提交时要保存的清单中

文件流转的三个工作区域：

* Git 的本地数据目录 - 每个项目都有一个 `.git` 目录，它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。*
* 工作目录 - 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 `.git` 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。
* 暂存区 -

### .gitignore

* 所有空行或者以注释符号 # 开头的行都会被 Git 忽略。
* 可以使用 glob 模式匹配。
* 匹配模式最后跟反斜杠 `/` 说明要忽略的是目录。
* 要忽略执行模式意外的文件或目录，可以在模式前加上惊叹号 `!` 取反。

所谓 glob 模式是指 shell 使用的简化的正则表达式。星号 `*` 匹配零或多个任意字符。`[abc]` 匹配任何一个列在方括号中的字符。问好 `?` 只匹配一个任意字符。如果方括号中使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配 `[0-9]`。

git 的所有命令后面都可以使用 glob 模式，比如 `git rm log/\*.log`

### 一些命令

```bash
git diff --staged # 查看已经暂存起来的文件和上次提交时的快照之间的差异
```

## 基础

fetch 命令只是将远端的数据拉到本地数据库，并不自动合并到当前工作分支，你需要手工合并。

## 分支

暂存操作会对每一个文件计算 **校验和** 也就是 SHA1 字符串，然后把当前版本的文件快照保存到 Git 仓库中（Git使用 blob 类型的对象存储这些快照），并将 **校验和** 加入暂存区域。

Git 的分支本质上一个指向 commit 对象的可变指针。它包含所指对象校验和 40个字符长度 SHA1 字串的文件，创建和销毁一个分支就很廉价。说白了，新建一个分支就是想一个文件写入 41 个字节外加一个换行符，当然很快了。

Git 保存一个名为 HEAD 的特别指针，用来标记你在哪个分支上工作。

转换分支的时候最好保持一个清洁的工作区域。

```bash
git branch -v # 查看各分支最后一次 commit 信息
git branch -merged # 查看哪些分支已经被合并
git branch --no-merged # 查看尚未合并的工作
```

当你在使用分支及合并时，一切都在自己本地的 Git 仓库中进行，完全不涉及与服务器的交互。

跟踪分支 tracking branch，是一种和远程分支有直接联系的本地分支。在跟踪分支里输入 git push 会自行推断应该向哪个远程服务器的哪个分支推送数据。

```
git rebase --onto master server client
```

检出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍。

可以直接把 server 分支变基到 master 而不用手工转到 server 分支再 rebase。`git rebase <主分支> <特性分支>` 会先检出特性分支 server，然后在 master 上重演。




## 在线阅读

* [Pro Git，第二版，简体中文](https://bingohuang.gitbooks.io/progit2/content/)
